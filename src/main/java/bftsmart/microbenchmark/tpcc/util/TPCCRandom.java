package bftsmart.microbenchmark.tpcc.util;

import java.math.BigDecimal;
import java.util.Random;

import bftsmart.microbenchmark.tpcc.config.TPCCConfig;

public class TPCCRandom {

    private static final char[] A_STRING_CHARS = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
            'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2',
            '3', '4', '5', '6', '7', '8', '9' };

    private static final String[] C_LAST_TOKENS =
            { "BAR", "OUGHT", "ABLE", "PRI", "PRES", "ESE", "ANTI", "CALLY", "ATION", "EING" };

    private final long nURandCCID;
    private final long nURandCIID;
    private long nURandCLast;

    private final Random random;

    /**
     * Used to create the master TPCCRandom() instance for loading the
     * database.
     */
    public TPCCRandom() {
        this.random = new Random(System.nanoTime());
        this.nURandCCID = nextLong(0, TPCCConfig.C_ID);
        this.nURandCIID = nextLong(0, TPCCConfig.OL_I_ID);
        this.nURandCLast = nextLong(0, TPCCConfig.C_LAST);
    }

    /**
     * <code>TPCCRandom(CLoad)</code>
     * <p>
     * Used to create the master TPCCRandom instance for running a benchmark
     * load.
     * TPC-C 2.1.6 defines the rules for picking the C values of the non-uniform
     * random number generator. In particular 2.1.6.1 defines what numbers for
     * the C value for generating C_LAST must be excluded from the possible
     * range during run time, based on the number used during the load.
     * </p>
     */
    public TPCCRandom(long cLoad) {
        long delta;

        this.random = new Random(System.nanoTime());
        this.nURandCCID = nextLong(0, TPCCConfig.C_ID);
        this.nURandCIID = nextLong(0, TPCCConfig.OL_I_ID);

        do {
            this.nURandCLast = nextLong(0, TPCCConfig.C_LAST);

            delta = Math.abs(this.nURandCLast - cLoad);
        } while (delta == 96 || delta < 65 || delta == 112 || delta > 119);
    }

    /**
     * <code>nextInt(x, y)</code>
     * <p>
     * Produce a random number uniformly distributed in [x .. y]
     * </p>
     */
    public int nextInt(int x, int y) {
        return (int) nextDouble(x, y);
    }

    /**
     * <code>nextLong(x, y)</code>
     * Produce a random number uniformly distributed in [x .. y]
     */
    public long nextLong(long x, long y) {
        return (long) nextDouble(x, y);
    }

    /**
     * <code>nextFloat(x, y)</code>
     * Produce a random number uniformly distributed in [x .. y]
     */
    public float nextFloat(long x, long y) {
        return (float) nextDouble(x, y);
    }

    /**
     * <code>nextDouble(x, y)</code>
     * Produce a random number uniformly distributed in [x .. y]
     */
    public double nextDouble(double x, double y) {
        return random.nextDouble() * (y - x + 1) + x;
    }

    /**
     * <code>nextBigDecimal(x, y)</code>
     * Produce a random number uniformly distributed in [x .. y]
     */
    public BigDecimal nextBigDecimal(double x, double y) {
        return BigDecimal.valueOf(nextDouble(x, y));
    }

    /**
     * The term non-uniform random, used only for generating customer numbers,
     * customer last names, and item numbers, means an independently selected
     * and non-uniformly distributed random number over the specified range of
     * values [x .. y]. This number must be generated by using the function N
     * URand which produces positions within the range [x .. y]. The results of
     * NURand might have to be converted to produce a name or a number valid for
     * the implementation.
     * 
     * <pre>
     * <code>NURand(A, x, y) = (((random(0, A) | random(x, y)) + C) % (y - x + 1)) + x</code>
     * </pre>
     * 
     * @param type
     *            C is a run-time constant randomly chosen within [0 .. A] that
     *            can be varied without altering performance
     * @param a
     *            A is a constant chosen according to the size of the range [x
     *            .. y]
     * @param x
     *            random (x, y) stands for randomly selected within [x .. y]
     * @param y
     *            random (x, y) stands for randomly selected within [x .. y]
     * @return
     */
    public long nonUniformRandom(long type, long a, long x, long y) {
        return (((nextLong(0L, a) | nextLong(x, y)) + type) % (y - x + 1)) + x;
    }

    /**
     * <code>getAString(s)</code>
     * <p>
     * Produces a random alphanumeric string of predefined length
     * Note: TPC-C 4.3.2.2 asks for an "alphanumeric" string. Comment 1 about
     * the character set does NOT mean that this function must eventually
     * produce 128 different characters, only that the "character set" used to
     * store this data must be able to represent 128 different characters.
     * '#@!%%ÄÖß' is not an alphanumeric string. We can save ourselves a lot of
     * UTF8 related trouble by producing alphanumeric only instead of cartoon
     * style curse-bubbles.
     * </p>
     */
    public String getAString(long length) {
        return getAString(length, length);
    }

    /**
     * <code>getAString(x, y)</code>
     * <p>
     * Produces a random alphanumeric string of length [x .. y].
     * Note: TPC-C 4.3.2.2 asks for an "alphanumeric" string. Comment 1 about
     * the character set does NOT mean that this function must eventually
     * produce 128 different characters, only that the "character set" used to
     * store this data must be able to represent 128 different characters.
     * '#@!%%ÄÖß' is not an alphanumeric string. We can save ourselves a lot of
     * UTF8 related trouble by producing alphanumeric only instead of cartoon
     * style curse-bubbles.
     * </p>
     */
    public String getAString(long x, long y) {
        StringBuilder result = new StringBuilder();
        long len = nextLong(x, y);
        long have = 1;

        if (y > 0) {
            result.append(A_STRING_CHARS[nextInt(0, 51)]);
            while (have < len) {
                result.append(A_STRING_CHARS[nextInt(0, 61)]);
                have++;
            }
        }
        return result.toString();
    }

    /**
     * 4.3.2.7 The warehouse zip code (W_ZIP), the district zip code (D_ZIP) and
     * the customer zip code (C_ZIP) must be generated by the concatenation of:
     * <ul>
     * <li>A random n-string of 4 numbers, and</li>
     * <li>The constant string '11111'.</li>
     * </ul>
     */
    public String getAZip() {
        return nextInt(1000, 9999) + "11111";
    }

    /**
     * Returns a random within [x .. y], uniformly distributed double value
     * between 0.0 and 1.0
     * 
     * @return Random within [x .. y]
     */
    public double getAPercent(double x, double y) {
        return (random.nextDouble() * (y - x)) + x;
    }

    /**
     * For 10% of the rows, selected at random, the string "ORIGINAL" must be
     * held by 8 consecutive characters starting at a random position within
     * I_DATA OR S_DATA
     * 
     * @return I_DATA/S_DATA random a-string [26 .. 50]
     */
    public String getData() {
        String data = getAString(26, 50);
        if (nextInt(1, 100) <= 10) {
            int number = nextInt(0, data.length() - 8);
            data = data.substring(0, number) + "ORIGINAL" + data.substring(number + 8, data.length());
        }
        return data;
    }

    /**
     * <code>getNString(length)</code>
     * <p>
     * Produce a random numeric string of predefined length.
     * </p>
     */
    public String getNString(long length) {
        return getNString(length, length);
    }

    /**
     * <code>getNString(x, y)</code>
     * <p>
     * Produce a random numeric string of length [x .. y].
     * </p>
     */
    public String getNString(long x, long y) {
        StringBuilder result = new StringBuilder();
        long len = nextLong(x, y);
        long have = 0;

        while (have < len) {
            result.append((char) (nextLong('0', '9')));
            have++;
        }

        return result.toString();
    }

    /**
     * <code>getCLast(num)</code>
     * <p>
     * Produce the syllable representation for C_LAST of [0 .. 999].
     * </p>
     */
    public String getCLast(int num) {
        return C_LAST_TOKENS[num / 100] + C_LAST_TOKENS[(num / 10) % 10] + C_LAST_TOKENS[num % 10];
    }

    /**
     * <code>getCLast()</code>
     * <p>
     * Produce a non uniform random Customer Last Name.
     * </p>
     */
    public String getCLast() {
        long num = nonUniformRandom(nURandCLast, TPCCConfig.C_LAST, 0, TPCCConfig.MAX_C_LAST);
        return getCLast((int) num);
    }

    /**
     * Produces a non uniform random Customer ID.
     * 
     * @return a customer ID
     */
    public int getCustomerID() {
        return (int) nonUniformRandom(nURandCCID, TPCCConfig.C_ID, 1, TPCCConfig.NB_MAX_CUSTOMER);
    }

    /**
     * Produce a non uniform random Item ID.
     * 
     * @return an Item ID
     */
    public int getItemID() {
        return (int) nonUniformRandom(nURandCIID, TPCCConfig.OL_I_ID, 1, TPCCConfig.NB_MAX_ITEM);
    }

    /**
     * Let C-Load be the value of C used to generate C_LAST when populating the
     * database. C-Load is a value in the range of [0..255] including 0 and 255.
     * 
     * @return The value of C-Load
     */
    public long getCLoad() {
        return nURandCLast;
    }

}
